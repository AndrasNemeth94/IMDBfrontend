{"ast":null,"code":"import { isArgumentElement, isDateElement, isDateTimeSkeleton, isLiteralElement, isNumberElement, isNumberSkeleton, isPluralElement, isPoundElement, isSelectElement, isTimeElement, isTagElement } from 'intl-messageformat-parser';\nimport { MissingValueError, InvalidValueError, FormatError, InvalidValueTypeError } from './error';\nexport var PART_TYPE;\n\n(function (PART_TYPE) {\n  PART_TYPE[PART_TYPE[\"literal\"] = 0] = \"literal\";\n  PART_TYPE[PART_TYPE[\"object\"] = 1] = \"object\";\n})(PART_TYPE || (PART_TYPE = {}));\n\nfunction mergeLiteral(parts) {\n  if (parts.length < 2) {\n    return parts;\n  }\n\n  return parts.reduce(function (all, part) {\n    var lastPart = all[all.length - 1];\n\n    if (!lastPart || lastPart.type !== 0\n    /* literal */\n    || part.type !== 0\n    /* literal */\n    ) {\n        all.push(part);\n      } else {\n      lastPart.value += part.value;\n    }\n\n    return all;\n  }, []);\n}\n\nexport function isFormatXMLElementFn(el) {\n  return typeof el === 'function';\n} // TODO(skeleton): add skeleton support\n\nexport function formatToParts(els, locales, formatters, formats, values, currentPluralValue, // For debugging\noriginalMessage) {\n  // Hot path for straight simple msg translations\n  if (els.length === 1 && isLiteralElement(els[0])) {\n    return [{\n      type: 0\n      /* literal */\n      ,\n      value: els[0].value\n    }];\n  }\n\n  var result = [];\n\n  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n    var el = els_1[_i]; // Exit early for string parts.\n\n    if (isLiteralElement(el)) {\n      result.push({\n        type: 0\n        /* literal */\n        ,\n        value: el.value\n      });\n      continue;\n    } // TODO: should this part be literal type?\n    // Replace `#` in plural rules with the actual numeric value.\n\n\n    if (isPoundElement(el)) {\n      if (typeof currentPluralValue === 'number') {\n        result.push({\n          type: 0\n          /* literal */\n          ,\n          value: formatters.getNumberFormat(locales).format(currentPluralValue)\n        });\n      }\n\n      continue;\n    }\n\n    var varName = el.value; // Enforce that all required values are provided by the caller.\n\n    if (!(values && varName in values)) {\n      throw new MissingValueError(varName, originalMessage);\n    }\n\n    var value = values[varName];\n\n    if (isArgumentElement(el)) {\n      if (!value || typeof value === 'string' || typeof value === 'number') {\n        value = typeof value === 'string' || typeof value === 'number' ? String(value) : '';\n      }\n\n      result.push({\n        type: typeof value === 'string' ? 0\n        /* literal */\n        : 1\n        /* object */\n        ,\n        value: value\n      });\n      continue;\n    } // Recursively format plural and select parts' option — which can be a\n    // nested pattern structure. The choosing of the option to use is\n    // abstracted-by and delegated-to the part helper object.\n\n\n    if (isDateElement(el)) {\n      var style = typeof el.style === 'string' ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : undefined;\n      result.push({\n        type: 0\n        /* literal */\n        ,\n        value: formatters.getDateTimeFormat(locales, style).format(value)\n      });\n      continue;\n    }\n\n    if (isTimeElement(el)) {\n      var style = typeof el.style === 'string' ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : undefined;\n      result.push({\n        type: 0\n        /* literal */\n        ,\n        value: formatters.getDateTimeFormat(locales, style).format(value)\n      });\n      continue;\n    }\n\n    if (isNumberElement(el)) {\n      var style = typeof el.style === 'string' ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : undefined;\n      result.push({\n        type: 0\n        /* literal */\n        ,\n        value: formatters.getNumberFormat(locales, style).format(value)\n      });\n      continue;\n    }\n\n    if (isTagElement(el)) {\n      var children = el.children,\n          value_1 = el.value;\n      var formatFn = values[value_1];\n\n      if (!isFormatXMLElementFn(formatFn)) {\n        throw new InvalidValueTypeError(value_1, 'function', originalMessage);\n      }\n\n      var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);\n      var chunks = formatFn(parts.map(function (p) {\n        return p.value;\n      }));\n\n      if (!Array.isArray(chunks)) {\n        chunks = [chunks];\n      }\n\n      result.push.apply(result, chunks.map(function (c) {\n        return {\n          type: typeof c === 'string' ? 0\n          /* literal */\n          : 1\n          /* object */\n          ,\n          value: c\n        };\n      }));\n    }\n\n    if (isSelectElement(el)) {\n      var opt = el.options[value] || el.options.other;\n\n      if (!opt) {\n        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n      }\n\n      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));\n      continue;\n    }\n\n    if (isPluralElement(el)) {\n      var opt = el.options[\"=\" + value];\n\n      if (!opt) {\n        if (!Intl.PluralRules) {\n          throw new FormatError(\"Intl.PluralRules is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-pluralrules\\\"\\n\", \"MISSING_INTL_API\"\n          /* MISSING_INTL_API */\n          , originalMessage);\n        }\n\n        var rule = formatters.getPluralRules(locales, {\n          type: el.pluralType\n        }).select(value - (el.offset || 0));\n        opt = el.options[rule] || el.options.other;\n      }\n\n      if (!opt) {\n        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n      }\n\n      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));\n      continue;\n    }\n  }\n\n  return mergeLiteral(result);\n}","map":{"version":3,"sources":["C:/Users/nemet/Desktop/mentőállomás/IMDBfrontend/node_modules/intl-messageformat/lib/src/formatters.js"],"names":["isArgumentElement","isDateElement","isDateTimeSkeleton","isLiteralElement","isNumberElement","isNumberSkeleton","isPluralElement","isPoundElement","isSelectElement","isTimeElement","isTagElement","MissingValueError","InvalidValueError","FormatError","InvalidValueTypeError","PART_TYPE","mergeLiteral","parts","length","reduce","all","part","lastPart","type","push","value","isFormatXMLElementFn","el","formatToParts","els","locales","formatters","formats","values","currentPluralValue","originalMessage","result","_i","els_1","getNumberFormat","format","varName","String","style","date","parsedOptions","undefined","getDateTimeFormat","time","number","children","value_1","formatFn","chunks","map","p","Array","isArray","apply","c","opt","options","other","Object","keys","Intl","PluralRules","rule","getPluralRules","pluralType","select","offset"],"mappings":"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","sourcesContent":["import { isArgumentElement, isDateElement, isDateTimeSkeleton, isLiteralElement, isNumberElement, isNumberSkeleton, isPluralElement, isPoundElement, isSelectElement, isTimeElement, isTagElement, } from 'intl-messageformat-parser';\r\nimport { MissingValueError, InvalidValueError, FormatError, InvalidValueTypeError, } from './error';\r\nexport var PART_TYPE;\r\n(function (PART_TYPE) {\r\n    PART_TYPE[PART_TYPE[\"literal\"] = 0] = \"literal\";\r\n    PART_TYPE[PART_TYPE[\"object\"] = 1] = \"object\";\r\n})(PART_TYPE || (PART_TYPE = {}));\r\nfunction mergeLiteral(parts) {\r\n    if (parts.length < 2) {\r\n        return parts;\r\n    }\r\n    return parts.reduce(function (all, part) {\r\n        var lastPart = all[all.length - 1];\r\n        if (!lastPart ||\r\n            lastPart.type !== 0 /* literal */ ||\r\n            part.type !== 0 /* literal */) {\r\n            all.push(part);\r\n        }\r\n        else {\r\n            lastPart.value += part.value;\r\n        }\r\n        return all;\r\n    }, []);\r\n}\r\nexport function isFormatXMLElementFn(el) {\r\n    return typeof el === 'function';\r\n}\r\n// TODO(skeleton): add skeleton support\r\nexport function formatToParts(els, locales, formatters, formats, values, currentPluralValue, \r\n// For debugging\r\noriginalMessage) {\r\n    // Hot path for straight simple msg translations\r\n    if (els.length === 1 && isLiteralElement(els[0])) {\r\n        return [\r\n            {\r\n                type: 0 /* literal */,\r\n                value: els[0].value,\r\n            },\r\n        ];\r\n    }\r\n    var result = [];\r\n    for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\r\n        var el = els_1[_i];\r\n        // Exit early for string parts.\r\n        if (isLiteralElement(el)) {\r\n            result.push({\r\n                type: 0 /* literal */,\r\n                value: el.value,\r\n            });\r\n            continue;\r\n        }\r\n        // TODO: should this part be literal type?\r\n        // Replace `#` in plural rules with the actual numeric value.\r\n        if (isPoundElement(el)) {\r\n            if (typeof currentPluralValue === 'number') {\r\n                result.push({\r\n                    type: 0 /* literal */,\r\n                    value: formatters.getNumberFormat(locales).format(currentPluralValue),\r\n                });\r\n            }\r\n            continue;\r\n        }\r\n        var varName = el.value;\r\n        // Enforce that all required values are provided by the caller.\r\n        if (!(values && varName in values)) {\r\n            throw new MissingValueError(varName, originalMessage);\r\n        }\r\n        var value = values[varName];\r\n        if (isArgumentElement(el)) {\r\n            if (!value || typeof value === 'string' || typeof value === 'number') {\r\n                value =\r\n                    typeof value === 'string' || typeof value === 'number'\r\n                        ? String(value)\r\n                        : '';\r\n            }\r\n            result.push({\r\n                type: typeof value === 'string' ? 0 /* literal */ : 1 /* object */,\r\n                value: value,\r\n            });\r\n            continue;\r\n        }\r\n        // Recursively format plural and select parts' option — which can be a\r\n        // nested pattern structure. The choosing of the option to use is\r\n        // abstracted-by and delegated-to the part helper object.\r\n        if (isDateElement(el)) {\r\n            var style = typeof el.style === 'string'\r\n                ? formats.date[el.style]\r\n                : isDateTimeSkeleton(el.style)\r\n                    ? el.style.parsedOptions\r\n                    : undefined;\r\n            result.push({\r\n                type: 0 /* literal */,\r\n                value: formatters\r\n                    .getDateTimeFormat(locales, style)\r\n                    .format(value),\r\n            });\r\n            continue;\r\n        }\r\n        if (isTimeElement(el)) {\r\n            var style = typeof el.style === 'string'\r\n                ? formats.time[el.style]\r\n                : isDateTimeSkeleton(el.style)\r\n                    ? el.style.parsedOptions\r\n                    : undefined;\r\n            result.push({\r\n                type: 0 /* literal */,\r\n                value: formatters\r\n                    .getDateTimeFormat(locales, style)\r\n                    .format(value),\r\n            });\r\n            continue;\r\n        }\r\n        if (isNumberElement(el)) {\r\n            var style = typeof el.style === 'string'\r\n                ? formats.number[el.style]\r\n                : isNumberSkeleton(el.style)\r\n                    ? el.style.parsedOptions\r\n                    : undefined;\r\n            result.push({\r\n                type: 0 /* literal */,\r\n                value: formatters\r\n                    .getNumberFormat(locales, style)\r\n                    .format(value),\r\n            });\r\n            continue;\r\n        }\r\n        if (isTagElement(el)) {\r\n            var children = el.children, value_1 = el.value;\r\n            var formatFn = values[value_1];\r\n            if (!isFormatXMLElementFn(formatFn)) {\r\n                throw new InvalidValueTypeError(value_1, 'function', originalMessage);\r\n            }\r\n            var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);\r\n            var chunks = formatFn(parts.map(function (p) { return p.value; }));\r\n            if (!Array.isArray(chunks)) {\r\n                chunks = [chunks];\r\n            }\r\n            result.push.apply(result, chunks.map(function (c) {\r\n                return {\r\n                    type: typeof c === 'string' ? 0 /* literal */ : 1 /* object */,\r\n                    value: c,\r\n                };\r\n            }));\r\n        }\r\n        if (isSelectElement(el)) {\r\n            var opt = el.options[value] || el.options.other;\r\n            if (!opt) {\r\n                throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\r\n            }\r\n            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));\r\n            continue;\r\n        }\r\n        if (isPluralElement(el)) {\r\n            var opt = el.options[\"=\" + value];\r\n            if (!opt) {\r\n                if (!Intl.PluralRules) {\r\n                    throw new FormatError(\"Intl.PluralRules is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-pluralrules\\\"\\n\", \"MISSING_INTL_API\" /* MISSING_INTL_API */, originalMessage);\r\n                }\r\n                var rule = formatters\r\n                    .getPluralRules(locales, { type: el.pluralType })\r\n                    .select(value - (el.offset || 0));\r\n                opt = el.options[rule] || el.options.other;\r\n            }\r\n            if (!opt) {\r\n                throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\r\n            }\r\n            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));\r\n            continue;\r\n        }\r\n    }\r\n    return mergeLiteral(result);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}